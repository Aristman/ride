# –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –∏ –∑–∞–ø—É—Å–∫ MCP Server

–†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π —É—Å—Ç–∞–Ω–æ–≤–∫–µ –∏ –∑–∞–ø—É—Å–∫—É MCP Server –ø—Ä–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–µ –ø–ª–∞–≥–∏–Ω–∞ Ride.

## –°—Ç—Ä–∞—Ç–µ–≥–∏–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–∏

### –í–∞—Ä–∏–∞–Ω—Ç 1: –í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π –±–∏–Ω–∞—Ä–Ω–∏–∫ (–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è)

–í–∫–ª—é—á–∏—Ç—å –ø—Ä–µ–¥—Å–æ–±—Ä–∞–Ω–Ω—ã–π –±–∏–Ω–∞—Ä–Ω–∏–∫ –≤ –¥–∏—Å—Ç—Ä–∏–±—É—Ç–∏–≤ –ø–ª–∞–≥–∏–Ω–∞.

#### –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞
- ‚úÖ –ù–µ —Ç—Ä–µ–±—É–µ—Ç Rust –Ω–∞ –º–∞—à–∏–Ω–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
- ‚úÖ –ë—ã—Å—Ç—Ä–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞
- ‚úÖ –ö–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–µ–º–∞—è –≤–µ—Ä—Å–∏—è

#### –ù–µ–¥–æ—Å—Ç–∞—Ç–∫–∏
- ‚ùå –£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç —Ä–∞–∑–º–µ—Ä –ø–ª–∞–≥–∏–Ω–∞ (~5-10 MB)
- ‚ùå –ù—É–∂–Ω—ã –±–∏–Ω–∞—Ä–Ω–∏–∫–∏ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –ø–ª–∞—Ç—Ñ–æ—Ä–º

### –í–∞—Ä–∏–∞–Ω—Ç 2: –°–∫–∞—á–∏–≤–∞–Ω–∏–µ –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –∑–∞–ø—É—Å–∫–µ

–°–∫–∞—á–∞—Ç—å –±–∏–Ω–∞—Ä–Ω–∏–∫ —Å GitHub Releases –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –∑–∞–ø—É—Å–∫–µ –ø–ª–∞–≥–∏–Ω–∞.

#### –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞
- ‚úÖ –ú–∞–ª–µ–Ω—å–∫–∏–π —Ä–∞–∑–º–µ—Ä –ø–ª–∞–≥–∏–Ω–∞
- ‚úÖ –í—Å–µ–≥–¥–∞ –∞–∫—Ç—É–∞–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è

#### –ù–µ–¥–æ—Å—Ç–∞—Ç–∫–∏
- ‚ùå –¢—Ä–µ–±—É–µ—Ç –∏–Ω—Ç–µ—Ä–Ω–µ—Ç
- ‚ùå –ú–µ–¥–ª–µ–Ω–Ω—ã–π –ø–µ—Ä–≤—ã–π –∑–∞–ø—É—Å–∫

### –í–∞—Ä–∏–∞–Ω—Ç 3: –°–±–æ—Ä–∫–∞ –∏–∑ –∏—Å—Ö–æ–¥–Ω–∏–∫–æ–≤

–°–æ–±—Ä–∞—Ç—å –∏–∑ –∏—Å—Ö–æ–¥–Ω–∏–∫–æ–≤ –ø—Ä–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–µ (–µ—Å–ª–∏ –µ—Å—Ç—å Rust).

#### –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞
- ‚úÖ –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø–æ–¥ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É—é —Å–∏—Å—Ç–µ–º—É
- ‚úÖ –ú–∞–ª–µ–Ω—å–∫–∏–π —Ä–∞–∑–º–µ—Ä –ø–ª–∞–≥–∏–Ω–∞

#### –ù–µ–¥–æ—Å—Ç–∞—Ç–∫–∏
- ‚ùå –¢—Ä–µ–±—É–µ—Ç Rust toolchain
- ‚ùå –î–æ–ª–≥–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞ (3-5 –º–∏–Ω—É—Ç)

## –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º–æ–µ —Ä–µ—à–µ–Ω–∏–µ: –ì–∏–±—Ä–∏–¥–Ω—ã–π –ø–æ–¥—Ö–æ–¥

–ö–æ–º–±–∏–Ω–∞—Ü–∏—è –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ 1 –∏ 2 —Å fallback –Ω–∞ –≤–∞—Ä–∏–∞–Ω—Ç 3.

```
1. –ü–æ–ø—ã—Ç–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π –±–∏–Ω–∞—Ä–Ω–∏–∫
   ‚Üì (–µ—Å–ª–∏ –Ω–µ—Ç)
2. –ü–æ–ø—ã—Ç–∫–∞ —Å–∫–∞—á–∞—Ç—å —Å GitHub Releases
   ‚Üì (–µ—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å)
3. –ü–æ–ø—ã—Ç–∫–∞ —Å–æ–±—Ä–∞—Ç—å –∏–∑ –∏—Å—Ö–æ–¥–Ω–∏–∫–æ–≤
   ‚Üì (–µ—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å)
4. –ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤—Ä—É—á–Ω—É—é
```

## –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –≤ Ride Plugin

### 1. –°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ä–µ—Å—É—Ä—Å–æ–≤

```
ride/
‚îú‚îÄ‚îÄ src/main/resources/
‚îÇ   ‚îî‚îÄ‚îÄ mcp-server/
‚îÇ       ‚îú‚îÄ‚îÄ mcp-server-windows-x64.exe
‚îÇ       ‚îú‚îÄ‚îÄ mcp-server-linux-x64
‚îÇ       ‚îú‚îÄ‚îÄ mcp-server-macos-x64
‚îÇ       ‚îî‚îÄ‚îÄ mcp-server-macos-arm64
‚îî‚îÄ‚îÄ build.gradle.kts
```

### 2. Gradle –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è

```kotlin
// build.gradle.kts

tasks {
    // –ó–∞–¥–∞—á–∞ –¥–ª—è —Å–±–æ—Ä–∫–∏ MCP —Å–µ—Ä–≤–µ—Ä–∞
    register("buildMCPServer") {
        group = "build"
        description = "Build MCP Server binaries"
        
        doLast {
            val mcpDir = file("../mcp-server-rust")
            val resourcesDir = file("src/main/resources/mcp-server")
            resourcesDir.mkdirs()
            
            // –°–±–æ—Ä–∫–∞ –¥–ª—è —Ç–µ–∫—É—â–µ–π –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã
            exec {
                workingDir = mcpDir
                commandLine("cargo", "build", "--release")
            }
            
            // –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –±–∏–Ω–∞—Ä–Ω–∏–∫–∞
            val targetDir = mcpDir.resolve("target/release")
            val binaryName = if (System.getProperty("os.name").contains("Windows")) {
                "mcp-server-rust.exe"
            } else {
                "mcp-server-rust"
            }
            
            val platformSuffix = when {
                System.getProperty("os.name").contains("Windows") -> "windows-x64.exe"
                System.getProperty("os.name").contains("Mac") -> {
                    if (System.getProperty("os.arch").contains("aarch64")) {
                        "macos-arm64"
                    } else {
                        "macos-x64"
                    }
                }
                else -> "linux-x64"
            }
            
            copy {
                from(targetDir.resolve(binaryName))
                into(resourcesDir)
                rename { "mcp-server-$platformSuffix" }
            }
        }
    }
    
    // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–±–∏—Ä–∞—Ç—å –ø–µ—Ä–µ–¥ buildPlugin
    named("buildPlugin") {
        dependsOn("buildMCPServer")
    }
}
```

### 3. MCPServerManager

```kotlin
package ru.marslab.ide.ride.mcp

import com.intellij.openapi.application.ApplicationManager
import com.intellij.openapi.components.Service
import com.intellij.openapi.diagnostic.Logger
import com.intellij.openapi.progress.ProgressIndicator
import com.intellij.openapi.progress.ProgressManager
import com.intellij.openapi.progress.Task
import java.io.File
import java.net.URI
import java.net.http.HttpClient
import java.net.http.HttpRequest
import java.net.http.HttpResponse
import java.nio.file.Files
import java.nio.file.StandardCopyOption
import java.nio.file.attribute.PosixFilePermission

@Service
class MCPServerManager {
    private val logger = Logger.getInstance(MCPServerManager::class.java)
    private var serverProcess: Process? = null
    private val serverPort = 3000
    private val serverUrl = "http://localhost:$serverPort"
    
    companion object {
        fun getInstance(): MCPServerManager {
            return ApplicationManager.getApplication().getService(MCPServerManager::class.java)
        }
        
        private const val GITHUB_RELEASE_URL = 
            "https://github.com/yourusername/ride/releases/latest/download"
    }
    
    /**
     * –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –∏ –∑–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞
     */
    fun ensureServerRunning(): Boolean {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–ø—É—â–µ–Ω –ª–∏ —É–∂–µ
        if (isServerRunning()) {
            logger.info("MCP Server already running")
            return true
        }
        
        // –ü–æ–ª—É—á–∞–µ–º –∏–ª–∏ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –±–∏–Ω–∞—Ä–Ω–∏–∫
        val serverBinary = getOrInstallServerBinary() ?: return false
        
        // –ó–∞–ø—É—Å–∫–∞–µ–º —Å–µ—Ä–≤–µ—Ä
        return startServer(serverBinary)
    }
    
    /**
     * –ü–æ–ª—É—á–∏—Ç—å –∏–ª–∏ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –±–∏–Ω–∞—Ä–Ω–∏–∫ —Å–µ—Ä–≤–µ—Ä–∞
     */
    private fun getOrInstallServerBinary(): File? {
        val serverDir = getServerDirectory()
        val binaryName = getServerBinaryName()
        val serverBinary = File(serverDir, binaryName)
        
        // 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –±–∏–Ω–∞—Ä–Ω–∏–∫
        if (serverBinary.exists() && serverBinary.canExecute()) {
            logger.info("Using existing MCP Server binary: ${serverBinary.absolutePath}")
            return serverBinary
        }
        
        // 2. –ò–∑–≤–ª–µ–∫–∞–µ–º –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π –±–∏–Ω–∞—Ä–Ω–∏–∫
        val embedded = extractEmbeddedBinary(serverBinary)
        if (embedded != null) {
            logger.info("Extracted embedded MCP Server binary")
            return embedded
        }
        
        // 3. –°–∫–∞—á–∏–≤–∞–µ–º —Å GitHub
        val downloaded = downloadServerBinary(serverBinary)
        if (downloaded != null) {
            logger.info("Downloaded MCP Server binary from GitHub")
            return downloaded
        }
        
        // 4. –°–æ–±–∏—Ä–∞–µ–º –∏–∑ –∏—Å—Ö–æ–¥–Ω–∏–∫–æ–≤
        val built = buildFromSource(serverBinary)
        if (built != null) {
            logger.info("Built MCP Server from source")
            return built
        }
        
        logger.error("Failed to obtain MCP Server binary")
        return null
    }
    
    /**
     * –ò–∑–≤–ª–µ—á—å –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π –±–∏–Ω–∞—Ä–Ω–∏–∫ –∏–∑ —Ä–µ—Å—É—Ä—Å–æ–≤
     */
    private fun extractEmbeddedBinary(targetFile: File): File? {
        return try {
            val platformSuffix = getPlatformSuffix()
            val resourcePath = "/mcp-server/mcp-server-$platformSuffix"
            
            val inputStream = javaClass.getResourceAsStream(resourcePath)
            if (inputStream == null) {
                logger.warn("Embedded binary not found: $resourcePath")
                return null
            }
            
            targetFile.parentFile.mkdirs()
            Files.copy(inputStream, targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING)
            
            // –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø—Ä–∞–≤–∞ –Ω–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ (Unix)
            if (!isWindows()) {
                val permissions = setOf(
                    PosixFilePermission.OWNER_READ,
                    PosixFilePermission.OWNER_WRITE,
                    PosixFilePermission.OWNER_EXECUTE
                )
                Files.setPosixFilePermissions(targetFile.toPath(), permissions)
            }
            
            targetFile
        } catch (e: Exception) {
            logger.error("Failed to extract embedded binary", e)
            null
        }
    }
    
    /**
     * –°–∫–∞—á–∞—Ç—å –±–∏–Ω–∞—Ä–Ω–∏–∫ —Å GitHub Releases
     */
    private fun downloadServerBinary(targetFile: File): File? {
        return try {
            ProgressManager.getInstance().run(object : Task.Backgroundable(
                null, 
                "Downloading MCP Server...", 
                true
            ) {
                override fun run(indicator: ProgressIndicator) {
                    indicator.text = "Downloading MCP Server binary..."
                    indicator.isIndeterminate = false
                    
                    val platformSuffix = getPlatformSuffix()
                    val downloadUrl = "$GITHUB_RELEASE_URL/mcp-server-$platformSuffix"
                    
                    val client = HttpClient.newHttpClient()
                    val request = HttpRequest.newBuilder()
                        .uri(URI.create(downloadUrl))
                        .GET()
                        .build()
                    
                    val response = client.send(
                        request, 
                        HttpResponse.BodyHandlers.ofInputStream()
                    )
                    
                    if (response.statusCode() == 200) {
                        targetFile.parentFile.mkdirs()
                        Files.copy(
                            response.body(), 
                            targetFile.toPath(), 
                            StandardCopyOption.REPLACE_EXISTING
                        )
                        
                        // –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø—Ä–∞–≤–∞ –Ω–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ
                        if (!isWindows()) {
                            val permissions = setOf(
                                PosixFilePermission.OWNER_READ,
                                PosixFilePermission.OWNER_WRITE,
                                PosixFilePermission.OWNER_EXECUTE
                            )
                            Files.setPosixFilePermissions(targetFile.toPath(), permissions)
                        }
                        
                        indicator.fraction = 1.0
                    } else {
                        logger.warn("Failed to download: HTTP ${response.statusCode()}")
                    }
                }
            })
            
            if (targetFile.exists()) targetFile else null
        } catch (e: Exception) {
            logger.error("Failed to download server binary", e)
            null
        }
    }
    
    /**
     * –°–æ–±—Ä–∞—Ç—å –∏–∑ –∏—Å—Ö–æ–¥–Ω–∏–∫–æ–≤ (–µ—Å–ª–∏ –µ—Å—Ç—å Rust)
     */
    private fun buildFromSource(targetFile: File): File? {
        return try {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ cargo
            val cargoCheck = ProcessBuilder("cargo", "--version")
                .redirectErrorStream(true)
                .start()
            
            if (cargoCheck.waitFor() != 0) {
                logger.warn("Cargo not found, cannot build from source")
                return null
            }
            
            ProgressManager.getInstance().run(object : Task.Backgroundable(
                null,
                "Building MCP Server from source...",
                false
            ) {
                override fun run(indicator: ProgressIndicator) {
                    indicator.text = "Building MCP Server (this may take a few minutes)..."
                    indicator.isIndeterminate = true
                    
                    // –ù–∞–π—Ç–∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é —Å –∏—Å—Ö–æ–¥–Ω–∏–∫–∞–º–∏
                    val sourceDir = findSourceDirectory()
                    if (sourceDir == null) {
                        logger.warn("Source directory not found")
                        return
                    }
                    
                    // –°–æ–±—Ä–∞—Ç—å –ø—Ä–æ–µ–∫—Ç
                    val buildProcess = ProcessBuilder()
                        .command("cargo", "build", "--release")
                        .directory(sourceDir)
                        .redirectErrorStream(true)
                        .start()
                    
                    val exitCode = buildProcess.waitFor()
                    if (exitCode == 0) {
                        // –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –±–∏–Ω–∞—Ä–Ω–∏–∫
                        val builtBinary = File(
                            sourceDir,
                            "target/release/${getServerBinaryName()}"
                        )
                        
                        if (builtBinary.exists()) {
                            targetFile.parentFile.mkdirs()
                            Files.copy(
                                builtBinary.toPath(),
                                targetFile.toPath(),
                                StandardCopyOption.REPLACE_EXISTING
                            )
                        }
                    }
                }
            })
            
            if (targetFile.exists()) targetFile else null
        } catch (e: Exception) {
            logger.error("Failed to build from source", e)
            null
        }
    }
    
    /**
     * –ó–∞–ø—É—Å—Ç–∏—Ç—å —Å–µ—Ä–≤–µ—Ä
     */
    private fun startServer(serverBinary: File): Boolean {
        return try {
            logger.info("Starting MCP Server: ${serverBinary.absolutePath}")
            
            // –°–æ–∑–¥–∞—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –µ—Å–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            val configFile = createDefaultConfig()
            
            // –ó–∞–ø—É—Å—Ç–∏—Ç—å –ø—Ä–æ—Ü–µ—Å—Å
            serverProcess = ProcessBuilder()
                .command(serverBinary.absolutePath)
                .directory(serverBinary.parentFile)
                .redirectErrorStream(true)
                .start()
            
            // –ñ–¥–µ–º –∑–∞–ø—É—Å–∫–∞ (–º–∞–∫—Å–∏–º—É–º 10 —Å–µ–∫—É–Ω–¥)
            var attempts = 0
            while (attempts < 20) {
                Thread.sleep(500)
                if (isServerRunning()) {
                    logger.info("MCP Server started successfully")
                    return true
                }
                attempts++
            }
            
            logger.error("MCP Server failed to start in time")
            stopServer()
            false
        } catch (e: Exception) {
            logger.error("Failed to start MCP Server", e)
            false
        }
    }
    
    /**
     * –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–µ—Ä–≤–µ—Ä
     */
    fun stopServer() {
        serverProcess?.let {
            try {
                it.destroy()
                it.waitFor(5, java.util.concurrent.TimeUnit.SECONDS)
                if (it.isAlive) {
                    it.destroyForcibly()
                }
                logger.info("MCP Server stopped")
            } catch (e: Exception) {
                logger.error("Error stopping MCP Server", e)
            }
        }
        serverProcess = null
    }
    
    /**
     * –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –∑–∞–ø—É—â–µ–Ω –ª–∏ —Å–µ—Ä–≤–µ—Ä
     */
    fun isServerRunning(): Boolean {
        return try {
            val client = HttpClient.newHttpClient()
            val request = HttpRequest.newBuilder()
                .uri(URI.create("$serverUrl/health"))
                .timeout(java.time.Duration.ofSeconds(2))
                .GET()
                .build()
            
            val response = client.send(request, HttpResponse.BodyHandlers.ofString())
            response.statusCode() == 200
        } catch (e: Exception) {
            false
        }
    }
    
    /**
     * –°–æ–∑–¥–∞—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
     */
    private fun createDefaultConfig(): File {
        val configFile = File(getServerDirectory(), "config.toml")
        
        if (!configFile.exists()) {
            val defaultConfig = """
                base_dir = "./data"
                max_file_size = 10485760
                allowed_extensions = []
                blocked_paths = ["/etc", "/sys", "/proc", "C:\\Windows"]
                verbose = false
            """.trimIndent()
            
            configFile.writeText(defaultConfig)
        }
        
        return configFile
    }
    
    // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã
    
    private fun getServerDirectory(): File {
        val pluginDir = File(System.getProperty("user.home"), ".ride")
        val serverDir = File(pluginDir, "mcp-server")
        serverDir.mkdirs()
        return serverDir
    }
    
    private fun getServerBinaryName(): String {
        return if (isWindows()) "mcp-server.exe" else "mcp-server"
    }
    
    private fun getPlatformSuffix(): String {
        return when {
            System.getProperty("os.name").contains("Windows", ignoreCase = true) -> 
                "windows-x64.exe"
            System.getProperty("os.name").contains("Mac", ignoreCase = true) -> {
                if (System.getProperty("os.arch").contains("aarch64")) {
                    "macos-arm64"
                } else {
                    "macos-x64"
                }
            }
            else -> "linux-x64"
        }
    }
    
    private fun isWindows(): Boolean {
        return System.getProperty("os.name").contains("Windows", ignoreCase = true)
    }
    
    private fun findSourceDirectory(): File? {
        // –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –Ω–∞–π—Ç–∏ –∏—Å—Ö–æ–¥–Ω–∏–∫–∏ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –ø–ª–∞–≥–∏–Ω–∞
        val possiblePaths = listOf(
            File("../mcp-server-rust"),
            File("../../mcp-server-rust"),
            File(System.getProperty("user.home"), ".ride/mcp-server-rust")
        )
        
        return possiblePaths.firstOrNull { it.exists() && File(it, "Cargo.toml").exists() }
    }
}
```

### 4. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –ø–ª–∞–≥–∏–Ω–∞

```kotlin
package ru.marslab.ide.ride

import com.intellij.openapi.project.Project
import com.intellij.openapi.startup.StartupActivity
import ru.marslab.ide.ride.mcp.MCPServerManager

class RideStartupActivity : StartupActivity {
    override fun runActivity(project: Project) {
        // –ó–∞–ø—É—Å—Ç–∏—Ç—å MCP —Å–µ—Ä–≤–µ—Ä –≤ —Ñ–æ–Ω–µ
        ApplicationManager.getApplication().executeOnPooledThread {
            val serverManager = MCPServerManager.getInstance()
            val started = serverManager.ensureServerRunning()
            
            if (!started) {
                // –ü–æ–∫–∞–∑–∞—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
                Notifications.Bus.notify(
                    Notification(
                        "Ride",
                        "MCP Server",
                        "Failed to start MCP Server. Some features may not work.",
                        NotificationType.WARNING
                    )
                )
            }
        }
    }
}
```

### 5. –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –≤ plugin.xml

```xml
<idea-plugin>
    <!-- Startup Activity -->
    <extensions defaultExtensionNs="com.intellij">
        <postStartupActivity implementation="ru.marslab.ide.ride.RideStartupActivity"/>
        
        <applicationService 
            serviceImplementation="ru.marslab.ide.ride.mcp.MCPServerManager"/>
    </extensions>
    
    <!-- –û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ -->
    <applicationListeners>
        <listener 
            class="ru.marslab.ide.ride.RideApplicationListener"
            topic="com.intellij.ide.AppLifecycleListener"/>
    </applicationListeners>
</idea-plugin>
```

### 6. Listener –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ —Å–µ—Ä–≤–µ—Ä–∞

```kotlin
package ru.marslab.ide.ride

import com.intellij.ide.AppLifecycleListener
import ru.marslab.ide.ride.mcp.MCPServerManager

class RideApplicationListener : AppLifecycleListener {
    override fun appWillBeClosed(isRestart: Boolean) {
        // –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å MCP —Å–µ—Ä–≤–µ—Ä –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ IDE
        MCPServerManager.getInstance().stopServer()
    }
}
```

## –°–±–æ—Ä–∫–∞ –±–∏–Ω–∞—Ä–Ω–∏–∫–æ–≤ –¥–ª—è –≤—Å–µ—Ö –ø–ª–∞—Ç—Ñ–æ—Ä–º

### GitHub Actions workflow

```yaml
# .github/workflows/build-mcp-server.yml
name: Build MCP Server

on:
  push:
    tags:
      - 'v*'

jobs:
  build:
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            artifact: mcp-server-linux-x64
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            artifact: mcp-server-windows-x64.exe
          - os: macos-latest
            target: x86_64-apple-darwin
            artifact: mcp-server-macos-x64
          - os: macos-latest
            target: aarch64-apple-darwin
            artifact: mcp-server-macos-arm64

    runs-on: ${{ matrix.os }}

    steps:
      - uses: actions/checkout@v3
      
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          target: ${{ matrix.target }}
          override: true
      
      - name: Build
        working-directory: mcp-server-rust
        run: cargo build --release --target ${{ matrix.target }}
      
      - name: Rename binary
        run: |
          if [ "${{ matrix.os }}" = "windows-latest" ]; then
            cp mcp-server-rust/target/${{ matrix.target }}/release/mcp-server-rust.exe ${{ matrix.artifact }}
          else
            cp mcp-server-rust/target/${{ matrix.target }}/release/mcp-server-rust ${{ matrix.artifact }}
          fi
        shell: bash
      
      - name: Upload artifact
        uses: actions/upload-artifact@v3
        with:
          name: ${{ matrix.artifact }}
          path: ${{ matrix.artifact }}
      
      - name: Release
        uses: softprops/action-gh-release@v1
        if: startsWith(github.ref, 'refs/tags/')
        with:
          files: ${{ matrix.artifact }}
```

## UI –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–µ—Ä–≤–µ—Ä–æ–º

### Settings panel

```kotlin
class MCPServerConfigurable : Configurable {
    private lateinit var panel: JPanel
    private lateinit var statusLabel: JLabel
    private lateinit var startButton: JButton
    private lateinit var stopButton: JButton
    private lateinit var autoStartCheckbox: JCheckBox
    
    override fun createComponent(): JComponent {
        panel = JPanel(BorderLayout())
        
        val serverManager = MCPServerManager.getInstance()
        
        // Status panel
        val statusPanel = JPanel(FlowLayout(FlowLayout.LEFT))
        statusLabel = JLabel()
        updateStatus()
        statusPanel.add(statusLabel)
        
        // Control buttons
        val controlPanel = JPanel(FlowLayout(FlowLayout.LEFT))
        
        startButton = JButton("Start Server").apply {
            addActionListener {
                ApplicationManager.getApplication().executeOnPooledThread {
                    serverManager.ensureServerRunning()
                    SwingUtilities.invokeLater { updateStatus() }
                }
            }
        }
        
        stopButton = JButton("Stop Server").apply {
            addActionListener {
                serverManager.stopServer()
                updateStatus()
            }
        }
        
        controlPanel.add(startButton)
        controlPanel.add(stopButton)
        
        // Auto-start option
        autoStartCheckbox = JCheckBox("Auto-start on IDE startup")
        
        panel.add(statusPanel, BorderLayout.NORTH)
        panel.add(controlPanel, BorderLayout.CENTER)
        panel.add(autoStartCheckbox, BorderLayout.SOUTH)
        
        return panel
    }
    
    private fun updateStatus() {
        val isRunning = MCPServerManager.getInstance().isServerRunning()
        statusLabel.text = if (isRunning) {
            "Status: ‚úì Running"
        } else {
            "Status: ‚úó Stopped"
        }
        startButton.isEnabled = !isRunning
        stopButton.isEnabled = isRunning
    }
    
    override fun isModified(): Boolean = true
    override fun apply() {}
    override fun getDisplayName(): String = "MCP Server"
}
```

## –†–µ–∑—é–º–µ

–†–µ–∞–ª–∏–∑–∞—Ü–∏—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –≤–∫–ª—é—á–∞–µ—Ç:

1. **–í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ –±–∏–Ω–∞—Ä–Ω–∏–∫–∏** –≤ —Ä–µ—Å—É—Ä—Å—ã –ø–ª–∞–≥–∏–Ω–∞
2. **–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ** –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –∑–∞–ø—É—Å–∫–µ
3. **Fallback –Ω–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ** —Å GitHub Releases
4. **Fallback –Ω–∞ —Å–±–æ—Ä–∫—É** –∏–∑ –∏—Å—Ö–æ–¥–Ω–∏–∫–æ–≤ (–µ—Å–ª–∏ –µ—Å—Ç—å Rust)
5. **–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –∑–∞–ø—É—Å–∫** –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ IDE
6. **–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞** –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ IDE
7. **UI –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è** —Å–µ—Ä–≤–µ—Ä–æ–º –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö
8. **CI/CD pipeline** –¥–ª—è —Å–±–æ—Ä–∫–∏ –±–∏–Ω–∞—Ä–Ω–∏–∫–æ–≤

–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–æ–ª—É—á–∞–µ—Ç –ø–æ–ª–Ω–æ—Å—Ç—å—é –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫—É—é —É—Å—Ç–∞–Ω–æ–≤–∫—É –±–µ–∑ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ —Ä—É—á–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π! üöÄ
