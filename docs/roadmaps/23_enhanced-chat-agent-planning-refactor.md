# Роадмап: Доработка EnhancedChatAgent - Умная оценка неопределенности и поэтапное планирование

## Цель
Переработать логику работы EnhancedChatAgent для реализации умной системы оценки неопределенности и поэтапного планирования с использованием RAG только на этапе составления плана.

## Текущая проблема
EnhancedChatAgent сейчас использует RAG обогащение на начальном этапе обработки запроса, что усложняет простые запросы. Нужно изменить архитектуру чтобы RAG применялся только при составлении плана решения.

## Новая архитектура взаимодействия
```
Запрос пользователя → Оценка сложности и однозначности → Составление плана → Выполнение плана → Результат
```

## Этапы реализации

### 1. Удаление прямого RAG обогащения из начального этапа
- [ ] Убрать интеграцию с MCPFileSystemAgent из начального этапа обработки
- [ ] Удалить RAG обогащение запроса до оценки сложности
- [ ] Изменить логику в `ChatService.enrichRequestWithRAG()` или методе обогащения
- [ ] Обновить системные промпты убрав упоминания о прямом RAG обогащении

**Файлы для изменения:**
- `src/main/kotlin/ru/marslab/ide/ride/service/ChatService.kt`
- `src/main/kotlin/ru/marslab/ide/ride/agent/impl/EnhancedChatAgent.kt`

### 2. Улучшение системы оценки неопределенности
- [ ] Расширить `UncertaintyAnalyzer` для оценки сложности запросов по шкале 0.0-1.0
- [ ] Добавить паттерны для определения многосложных задач требующих планирования
- [ ] Создать пороговые значения для принятия решений:
  - `0.0-0.2`: Простой запрос (один шаг)
  - `0.2-0.5`: Средняя сложность (может потребоваться планирование)
  - `0.5-1.0`: Сложная задача (требует составления плана)

**Новые классы:**
- `RequestComplexityAnalyzer` - анализ сложности запроса
- `UncertaintyThresholds` - конфигурация порогов неопределенности

### 3. Создание системы планирования запросов
- [ ] Создать `RequestPlanner` - компонент для составления планов решения
- [ ] Реализовать логику определения необходимости дополнительных шагов
- [ ] Добавить интеграцию с RAG только на этапе планирования:
  - Поиск релевантных файлов проекта
  - Анализ контекста для составления плана
  - Обогащение плана информацией из проекта

**Классы для создания:**
- `RequestPlanner` - основной планировщик
- `PlanStep` - модель шага плана
- `ExecutionPlan` - модель полного плана выполнения
- `RAGPlanEnricher` - RAG обогащение для планирования

### 4. Интеграция RAG на этапе планирования
- [ ] Создать специализированный RAG агент для обогащения планов
- [ ] Реализовать логику поиска контекстной информации для составления шагов
- [ ] Добавить возможность динамического добавления шагов на основе RAG результатов
- [ ] Настроить интеграцию с MCPFileSystemAgent только для этапа планирования

**Функциональность:**
- Поиск файлов по ключевым словам из запроса
- Чтение содержимого релевантных файлов
- Анализ структуры проекта для составления плана
- Динамическое добавление шагов на основе найденной информации

### 5. Внедрение динамической модификации планов
**Сложность:** Средняя | **Необходимость:** Высокая | **Статус компонента:** Уже реализован (требует интеграции)

На основе существующей реализации `DynamicPlanModifier.kt.disabled` (376 строк) - полноценная система динамической модификации планов выполнения.

#### 5.1. Анализ существующей реализации
- [ ] Изучить архитектуру `DynamicPlanModifier` и `ConditionalStepExecutor`
- [ ] Оценить совместимость с новой моделью `ExecutionPlan`
- [ ] Проверить зависимости от `ToolAgentRegistry` и `ExecutionContext`
- [ ] Проанализировать систему условных шагов `ConditionalStep`

**Ключевые возможности existing implementation:**
- ✅ Добавление/удаление/замена шагов в runtime
- ✅ Условное выполнение шагов на основе результатов предыдущих
- ✅ Динамическое изменение порядка выполнения
- ✅ Обновление зависимостей между шагами
- ✅ Версионирование планов при изменениях

#### 5.2. Интеграция с новой архитектурой
- [ ] Перенести `DynamicPlanModifier` из `.disabled` в основной код
- [ ] Адаптировать под новые модели `ExecutionPlan` и `PlanStep`
- [ ] Интегрировать в `RequestPlanner` для динамического обогащения планов
- [ ] Настроить работу с `ConditionalStepExecutor` в контексте оркестрации

**Модификации для интеграции:**
```kotlin
// Интеграция в RequestPlanner
class RequestPlanner {
    private val dynamicModifier = DynamicPlanModifier()

    suspend fun createAdaptivePlan(request: String): ExecutionPlan {
        val basePlan = createBasePlan(request)

        // RAG обогащение с динамической модификацией
        val enrichedPlan = ragEnricher.enrichPlan(basePlan, request)

        // Динамическая модификация на основе контекста
        return dynamicModifier.enrichWithConditionalSteps(enrichedPlan, request)
    }
}
```

#### 5.3. Условная логика на основе результатов выполнения
- [ ] Включить `ConditionalStepExecutor` в цепочку выполнения оркестратора
- [ ] Настроить условные шаги для различных сценариев:
  - **Найдены критические проблемы** → добавить шаги детального анализа
  - **Обнаружены ошибки компиляции** → добавить шаги исправления
  - **Большой размер проекта** → добавить шаги сегментации
  - **Отсутствие документации** → добавить шаги генерации документации

**Примеры условных шагов:**
```kotlin
// Условный шаг для критических находок
val criticalFindingStep = ConditionalStep(
    id = "check_critical_findings",
    description = "Проверить наличие критических проблем",
    condition = { ctx, results ->
        val findings = results["analyze"]?.get<List<Finding>>("findings") ?: emptyList()
        findings.any { it.severity == Severity.CRITICAL }
    },
    thenStep = ToolPlanStep.detailedAnalysis(),
    elseStep = ToolPlanStep.continueToReport()
)
```

#### 5.4. Интеграция с RAG обогащением
- [ ] Реализовать динамическое добавление шагов на основе найденных файлов
- [ ] Настроить условия для добавления шагов анализа конкретных файлов
- [ ] Создать логику модификации планов на основе размера и сложности проекта

**Пример динамического обогащения:**
```kotlin
// После RAG анализа найдены новые файлы
if (foundNewArchitectureFiles) {
    plan = dynamicModifier.addStepsAfter(
        plan = plan,
        newSteps = listOf(
            PlanStep.analyzeArchitecture(),
            PlanStep.checkPatterns()
        ),
        afterStepId = "initial_scan"
    )
}
```

#### 5.5. Тестирование динамической модификации
- [ ] Создать тесты для `DynamicPlanModifier` с различными сценариями
- [ ] Протестировать условную логику `ConditionalStepExecutor`
- [ ] Написать интеграционные тесты для адаптивных планов
- [ ] Проверить корректность версионирования и метаданных

**Тестовые сценарии:**
- Динамическое добавление шагов после RAG анализа
- Условное выполнение на основе результатов предыдущих шагов
- Модификация планов в процессе выполнения
- Откат изменений при ошибках

#### 5.6. Оптимизация производительности
- [ ] Настроить кэширование результатов условных проверок
- [ ] Оптимизировать операции модификации планов
- [ ] Реализовать ленивое создание условных шагов
- [ ] Добавить мониторинг производительности динамических операций

**Оценка компонента:**
- **Готовность:** 90% (требуется адаптация)
- **Сложность интеграции:** Средняя
- **Польза для системы:** Высокая
- **Время внедрения:** 2-3 дня

### 6. Переработка логики EnhancedChatAgent
- [ ] Изменить метод `ask()` для реализации новой архитектуры
- [ ] Добавить проверку на необходимость планирования через оценку неопределенности
- [ ] Реализовать условное выполнение:
  - Низкая неопределенность → прямой ответ
  - Высокая неопределенность → составление плана → выполнение

**Новая логика в EnhancedChatAgent:**
```kotlin
suspend fun ask(request: AgentRequest): AgentResponse {
    // 1. Оценка неопределенности
    val uncertainty = analyzeUncertainty(request)

    return when {
        uncertainty < THRESHOLD_SIMPLE -> {
            // Простой запрос - прямой ответ
            baseChatAgent.ask(request)
        }
        uncertainty < THRESHOLD_COMPLEX -> {
            // Средняя сложность - может быть нужен план
            createAndExecuteSimplePlan(request, uncertainty)
        }
        else -> {
            // Сложная задача - полный план с RAG обогащением и динамической модификацией
            createAndExecuteComplexPlan(request, uncertainty)
        }
    }
}
```

### 7. Оптимизация простых запросов
- [ ] Реализовать быстрые ответы для запросов с низкой неопределенностью
- [ ] Добавить кэширование результатов для простых запросов
- [ ] Оптимизировать системные промпты для простых сценариев
- [ ] Убрать лишние шаги обработки для однозначных запросов

**Оптимизации:**
- Минимальное количество шагов для простых запросов
- Быстрая оценка без вызова LLM когда возможно
- Кэширование часто задаваемых вопросов

### 8. Тестирование новой архитектуры
- [ ] Создать тесты для `RequestComplexityAnalyzer`
- [ ] Написать тесты для `RequestPlanner` с различными уровнями сложности
- [ ] Протестировать интеграцию RAG на этапе планирования
- [ ] Создать тесты для `DynamicPlanModifier` и условных шагов
- [ ] Создать интеграционные тесты для полной цепочки обработки

**Тестовые классы:**
- `RequestComplexityAnalyzerTest`
- `RequestPlannerTest`
- `RAGPlanEnricherTest`
- `DynamicPlanModifierTest`
- `ConditionalStepExecutorTest`
- `EnhancedChatAgentNewArchitectureTest`

### 9. Обновление документации и примеров
- [ ] Обновить `CLAUDE.md` с описанием новой архитектуры
- [ ] Создать документацию по системе планирования
- [ ] Добавить документацию по динамической модификации планов
- [ ] Добавить примеры использования с различными уровнями сложности
- [ ] Обновить roadmap документацию

## Технические детали

### Пороговые значения неопределенности
```kotlin
object UncertaintyThresholds {
    const val SIMPLE_REQUEST_MAX = 0.2      // Прямой ответ
    const val MEDIUM_COMPLEXITY_MAX = 0.5    // Простой план
    const val COMPLEX_TASK_MIN = 0.5         // Полный план с RAG
}
```

### Пример новой архитектуры
```kotlin
// Простой запрос (неопределенность 0.1)
"Какая погода сегодня?" → Прямой ответ

// Средней сложности (неопределенность 0.3)
"Как оптимизировать этот метод?" → Простой план без RAG

// Сложный запрос (неопределенность 0.8)
"Проанализируй архитектуру всего проекта и предложи улучшения"
→ Полный план с RAG обогащением
```

### RAG интеграция только на этапе планирования
```kotlin
class RAGPlanEnricher {
    suspend fun enrichPlan(
        request: String,
        basePlan: ExecutionPlan
    ): ExecutionPlan {
        // Поиск релевантных файлов
        val contextFiles = findRelevantFiles(request)

        // Обогащение плана на основе контекста
        return addStepsBasedOnContext(basePlan, contextFiles)
    }
}
```

## Приоритеты

**Высокий приоритет:**
- Этапы 1-2 (убрать RAG из начального этапа, улучшить оценку неопределенности)
- Этап 3 (создание системы планирования)
- Этап 5 (внедрение динамической модификации планов)

**Средний приоритет:**
- Этапы 4, 6 (интеграция RAG в планирование, переработка EnhancedChatAgent)

**Низкий приоритет:**
- Этапы 7-9 (оптимизация, тестирование, документация)

## Ожидаемые результаты

### Упрощение простых запросов
- Сокращение времени обработки простых вопросов на 60-70%
- Уменьшение количества шагов для однозначных запросов
- Снижение нагрузки на систему для базовых сценариев

### Улучшение сложных запросов
- Более точное планирование за счет RAG обогащения на этапе составления плана
- Динамическое добавление релевантных шагов на основе контекста проекта
- Лучшее понимание архитектуры проекта при планировании
- Адаптивные планы, которые меняются в процессе выполнения

### Динамическая адаптивность
- Условное выполнение шагов на основе результатов предыдущих этапов
- Автоматическое добавление шагов при обнаружении новых проблем
- Версионирование планов для отслеживания изменений
- Гибкая модификация планов в runtime без остановки выполнения

### Гибкость системы
- Адаптивная обработка запросов разного уровня сложности
- Минимальные затраты на простые запросы
- Максимальная помощь для сложных задач
- Умная реакция на изменения контекста в процессе работы

## Риски и митигации

1. **Риск:** Усложнение архитектуры может привести к ошибкам
   **Митигация:** Постепенное внедрение с полным тестированием

2. **Риск:** RAG только на этапе планирования может пропустить важный контекст
   **Митигация:** Качественная реализация поиска релевантной информации

3. **Риск:** Оценка неопределенности может быть неточной
   **Митигация:** Обширное тестирование и настройка пороговых значений

4. **Риск:** Динамическая модификация планов может привести к бесконечным циклам
   **Митигация:** Ограничение количества модификаций, валидация циклических зависимостей, механизм отката

## Сроки реализации

- **Этапы 1-2:** 3-4 дня
- **Этапы 3-4:** 4-5 дней
- **Этап 5:** 2-3 дня (динамическая модификация планов)
- **Этапы 6-7:** 3-4 дня
- **Этапы 8-9:** 2-3 дня

**Общая оценка:** 14-19 дней (~3-4 рабочих недели)

---

**Дата создания:** 2025-11-01
**Версия:** 1.0
**Автор:** Claude AI Assistant
**Статус:** Ожидает утверждения

// Блок, не относящийся к плану
// Промпт для создания плана
План доработок агента EnhancedChatAgent
1. Убери обогащение запроса после RAG посредствам MCPFileSystemAgent и других средств для доступа к файловой системе.
2. Цепочка взаимодействия с пользователем будет выглядеть так
Запрос пользвателя - Оценка сложности и однозначиности для ответа (нужно использовать оценочную шкалу неопределенности) - Составление плана решения запроса пользователя (в этом этапе возможны дополнительные запросы для устранения неопределенностей к разным агентам, в том числе и запрос к RAG для обогащения информацией из проекта) - Выполенние плана по шагам (тут идут зарпосы и использование тулзов и агентов) - выдача результата пользователю.
3. Не нужно усложнять ответ если можно получить его за минимальное количество шагов. Нужно использовать обогащение от RAG для составления новых шагов (например - искать и читать файлы проекта, находить дополнительную информаци, составлять дополнительные шаги плана)

Составь по указанному плану роадмап, запиши роадмап в docs/roadmaps с неймингом как у имеющихся там файлов.
Дождись утвержения роадмап

// Дополнительный промпт
Добавь в план этап по динамической модификации плана в процессе разработки. В проекте есть @src/main/kotlin/ru/marslab/ide/ride/agent/DynamicPlanModifier.kt и его реализация в
@src/main/kotlin/ru/marslab/ide/ride/agent/DynamicPlanModifier.kt.disabled Изучи эти реализации и опиши в плане доработки этап внедрения данной функциональности. Оцени сложность и необходимость этого внедрения 