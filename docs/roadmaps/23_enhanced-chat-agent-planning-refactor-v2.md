# План разработки: Умная оценка неопределенности и адаптивное планирование EnhancedChatAgent

**Спецификация:** [enhanced-chat-agent-planning-spec.md](../specs/enhanced-chat-agent-planning-spec.md)
**Версия:** 2.0 (план разработки)
**Дата:** 2025-11-01
**Статус:** К реализации

## Описание для разработки

Необходимо переработать архитектуру EnhancedChatAgent для реализации умной системы оценки неопределенности с адаптивным планированием. Ключевые изменения:

1. **Убрать RAG обогащение из начального этапа** - простые запросы должны обрабатываться напрямую
2. **Внедрить оценку неопределенности** - 3 уровня сложности (простой/средний/сложный)
3. **RAG только для планирования** - обогащение информацией от проекта при составлении плана
4. **Динамическая модификация планов** - адаптация в процессе выполнения на основе результатов
5. **Минимизировать шаги** - для простых запросов прямой ответ без лишних операций

**Целевые метрики:**
- Сокращение времени обработки простых запросов на 60-70%
- Точность оценки неопределенности > 80%
- Поддержка обратной совместимости

---

## Фаза 1: Подготовка и очистка архитектуры (2 дня)

### 1.1 Удаление прямого RAG обогащения
- [ ] Убрать интеграцию с MCPFileSystemAgent из начального этапа обработки в `ChatService.kt`
- [ ] Удалить RAG обогащение запроса до оценки сложности в `EnhancedChatAgent.kt`
- [ ] Изменить логику в методе `enrichRequestWithRAG()` если существует
- [ ] Обновить системные промпты убрав упоминания о прямом RAG обогащении
- [ ] Проверить и удалить неиспользуемые импорты после очистки

### 1.2 Анализ и подготовка кодовой базы
- [ ] Проанализировать текущие зависимости от RAG в `ChatService`
- [ ] Проверить существующие методы оценки сложности в `EnhancedChatAgent`
- [ ] Изучить существующие модели `ExecutionPlan` и `PlanStep` для совместимости
- [ ] Создать ветку разработки `feature/enhanced-chat-agent-planning`

### 1.3 Подготовка тестовой среды
- [ ] Создать базовые тесты для текущей функциональности (regression тесты)
- [ ] Настроить тестовые данные для различных уровней сложности запросов
- [ ] Проверить что все существующие тесты проходят после очистки

---

## Фаза 2: Внедрение оценки неопределенности (3 дня)

### 2.1 Создание RequestComplexityAnalyzer
- [ ] Создать класс `RequestComplexityAnalyzer` в пакете `ru.marslab.ide.ride.agent.analyzer`
- [ ] Реализовать метод `analyzeUncertainty(request: String, context: ChatContext): UncertaintyResult`
- [ ] Создать модель `UncertaintyResult` с полями score, complexity, suggestedActions, reasoning
- [ ] Создать enum `ComplexityLevel` (SIMPLE, MEDIUM, COMPLEX)
- [ ] Реализовать эвристические паттерны для быстрой оценки простых запросов
- [ ] Добавить лексический анализ для определения ключевых слов сложности

### 2.2 Пороговые значения и конфигурация
- [ ] Создать объект `UncertaintyThresholds` с константами порогов
- [ ] Реализовать конфигурируемость порогов через `PluginSettings`
- [ ] Добавить валидацию пороговых значений

### 2.3 Тестирование анализатора
- [ ] Создать `RequestComplexityAnalyzerTest` с тестовыми сценариями:
  - [ ] Простые вопросы (погода, время, факты)
  - [ ] Запросы средней сложности (оптимизация метода)
  - [ ] Сложные запросы (анализ архитектуры проекта)
- [ ] Добавить тесты для паттернов сложности
- [ ] Протестировать пограничные значения порогов
- [ ] Проверить производительность анализатора

---

## Фаза 3: Создание системы планирования (4 дня)

### 3.1 Разработка RequestPlanner
- [ ] Создать класс `RequestPlanner` в пакете `ru.marslab.ide.ride.agent.planner`
- [ ] Реализовать метод `createPlan(request: String, uncertainty: UncertaintyResult, context: ChatContext): ExecutionPlan`
- [ ] Создать модель `ExecutionPlan` с необходимыми полями
- [ ] Реализовать создание простых планов для средней сложности
- [ ] Реализовать создание базовых планов для сложных запросов

### 3.2 Модели шагов и зависимостей
- [ ] Расширить/создать модель `PlanStep` с поддержкой различных типов шагов
- [ ] Реализовать систему зависимостей между шагами
- [ ] Создать модель `PlanStepResult` для результатов выполнения
- [ ] Добавить метаданные для шагов (время выполнения, ресурсы)

### 3.3 Интеграция с оркестратором
- [ ] Адаптировать `EnhancedAgentOrchestrator` для работы с новыми планами
- [ ] Реализовать выполнение простых планов без RAG обогащения
- [ ] Добавить поддержку метаданных и прогресса для новых планов

### 3.4 Тестирование планировщика
- [ ] Создать `RequestPlannerTest` с тестами:
  - [ ] Генерация простых планов
  - [ ] Создание сложных планов с зависимостями
  - [ ] Валидация шагов и зависимостей
- [ ] Интеграционные тесты с оркестратором
- [ ] Тесты производительности для генерации планов

---

## Фаза 4: RAG обогащение на этапе планирования (3 дня)

### 4.1 Создание RAGPlanEnricher
- [ ] Создать класс `RAGPlanEnricher` в пакете `ru.marslab.ide.ride.agent.rag`
- [ ] Реализовать метод `enrichPlan(plan: ExecutionPlan, request: String, context: ChatContext): ExecutionPlan`
- [ ] Интегрироваться с `MCPFileSystemAgent` только для этапа планирования
- [ ] Реализовать поиск релевантных файлов по ключевым словам из запроса

### 4.2 Логика обогащения планов
- [ ] Реализовать анализ найденных файлов для составления дополнительных шагов
- [ ] Добавить логику динамического добавления шагов на основе контекста проекта
- [ ] Создать эвристики для определения релевантности файлов
- [ ] Реализовать кэширование результатов поиска файлов

### 4.3 Интеграция в планировщик
- [ ] Модифицировать `RequestPlanner` для использования RAG обогащения
- [ ] Реализовать условное обогащение только для сложных запросов
- [ ] Добавить fallback на случай недоступности RAG

### 4.4 Тестирование RAG обогащения
- [ ] Создать `RAGPlanEnricherTest`
- [ ] Тесты обогащения на различных типах проектов
- [ ] Тесты производительности поиска файлов
- [ ] Интеграционные тесты с MCPFileSystemAgent

---

## Фаза 5: Интеграция динамической модификации планов (3 дня)

### 5.1 Активация существующего DynamicPlanModifier
- [ ] Перенести `DynamicPlanModifier.kt.disabled` в основной код
- [ ] Адаптировать под новые модели `ExecutionPlan` и `PlanStep`
- [ ] Проверить совместимость с `ToolAgentRegistry` и `ExecutionContext`
- [ ] Интегрировать в `RequestPlanner` для динамического обогащения

### 5.2 Условные шаги и адаптация
- [ ] Включить `ConditionalStepExecutor` в цепочку выполнения оркестратора
- [ ] Реализовать условные шаги для сценариев:
  - [ ] Найдены критические проблемы → детальный анализ
  - [ ] Обнаружены ошибки компиляции → шаги исправления
  - [ ] Большой размер проекта → сегментация
- [ ] Настроить условия для добавления шагов анализа конкретных файлов

### 5.3 Интеграция с RAG и оркестратором
- [ ] Реализовать динамическое добавление шагов на основе найденных файлов
- [ ] Настроить работу `ConditionalStepExecutor` в контексте оркестрации
- [ ] Создать логику модификации планов на основе размера и сложности проекта

### 5.4 Тестирование динамической модификации
- [ ] Создать `DynamicPlanModifierTest`
- [ ] Создать `ConditionalStepExecutorTest`
- [ ] Тесты адаптивных планов
- [ ] Интеграционные тесты полной цепочки с динамикой

---

## Фаза 6: Переработка EnhancedChatAgent (2 дня)

### 6.1 Новая логика обработки запросов
- [ ] Изменить метод `ask()` в `EnhancedChatAgent` для новой архитектуры
- [ ] Реализовать условное выполнение на основе оценки неопределенности
- [ ] Интегрировать все компоненты: анализатор, планировщик, RAG, динамическую модификацию
- [ ] Добавить поддержку возобновления планов

### 6.2 Оптимизация производительности
- [ ] Реализовать кэширование результатов оценки неопределенности
- [ ] Оптимизировать быстрые пути для простых запросов
- [ ] Добавить ленивую инициализацию компонентов
- [ ] Внедрить мониторинг производительности

### 6.3 Обратная совместимость
- [ ] Проверить совместимость с существующим API
- [ ] Обеспечить плавный переход для существующих пользователей
- [ ] Создать миграционные скрипты если необходимо

### 6.4 Тестирование EnhancedChatAgent
- [ ] Создать `EnhancedChatAgentNewArchitectureTest`
- [ ] Регрессионные тесты для существующей функциональности
- [ ] Тесты производительности для разных уровней сложности
- [ ] Интеграционные тесты полной цепочки обработки

---

## Фаза 7: Оптимизация и финализация (2 дня)

### 7.1 Оптимизация простых запросов
- [ ] Реализовать кэширование результатов для простых запросов
- [ ] Оптимизировать системные промпты для простых сценариев
- [ ] Убрать лишние шаги обработки для однозначных запросов
- [ ] Добавить предсказание кэша на основе паттернов

### 7.2 Мониторинг и метрики
- [ ] Добавить сбор метрик производительности
- [ ] Реализовать детальное логирование процесса принятия решений
- [ ] Создать дашборд для мониторинга (если применимо)
- [ ] Добавить алерты для аномального поведения

### 7.3 Финальное тестирование
- [ ] Запустить полный набор тестов
- [ ] Провести нагрузочное тестирование
- [ ] Проверить работу на реальных проектах
- [ ] Валидировать достижение целевых метрик

---

## Фаза 8: Документация и развертывание (1 день)

### 8.1 Обновление документации
- [ ] Обновить `CLAUDE.md` с описанием новой архитектуры
- [ ] Создать документацию по системе планирования
- [ ] Добавить документацию по динамической модификации планов
- [ ] Обновить README и CHANGELOG

### 8.2 Примеры использования
- [ ] Создать примеры использования с различными уровнями сложности
- [ ] Добавить примеры конфигурации порогов
- [ ] Создать гайды по миграции для существующих пользователей

### 8.3 Подготовка к релизу
- [ ] Провести финальную проверку кода
- [ ] Обновить версии и зависимости
- [ ] Подготовить release notes
- [ ] Создать ветку для релиза

---

## Критерии завершения

### Функциональные требования
- [ ] Простые запросы обрабатываются за < 1 секунды
- [ ] Оценка неопределенности точность > 80%
- [ ] Динамическая модификация планов работает без ошибок
- [ ] RAG обогащение только на этапе планирования

### Нефункциональные требования
- [ ] Обратная совместимость с существующим API
- [ ] Производительность не хуже текущей для сложных запросов
- [ ] Покрытие тестами > 80%
- [ ] Полная документация и примеры

### Демо
- [ ] Демонстрация обработки простого запроса (прямой ответ)
- [ ] Демонстрация сложного запроса с планированием и RAG
- [ ] Демонстрация динамической модификации плана
- [ ] Сравнение производительности до и после

---

**Общая оценка времени:** 20 дней (~4 рабочих недели)
**Команда:** 1 senior developer
**Риски:** Средние (новая архитектура, интеграция существующих компонентов)
**Зависимости:** Требуется доступ к тестовым проектам для валидации